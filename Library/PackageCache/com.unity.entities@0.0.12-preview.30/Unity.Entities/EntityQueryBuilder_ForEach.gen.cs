//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Generated by EntityQueryBuilder.tt (129 `foreach` combinations)

using System;
using System.ComponentModel;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;

namespace Unity.Entities
{
    public partial struct EntityQueryBuilder
    {

        public delegate void F_E(Entity entity);

        public unsafe void ForEach(F_E action)
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    query = ResolveEntityQuery(null, 0);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i]);
                    }
                }
            }
        }


        public delegate void F_ED<T0>(Entity entity, ref T0 c0)
            where T0 : struct, IComponentData;

        public unsafe void ForEach<T0>(F_ED<T0> action)
            where T0 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[1];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();

                    query = ResolveEntityQuery(delegateTypes, 1);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i));
                    }
                }
            }
        }


        public delegate void F_D<T0>(ref T0 c0)
            where T0 : struct, IComponentData;

        public unsafe void ForEach<T0>(F_D<T0> action)
            where T0 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[1];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();

                    query = ResolveEntityQuery(delegateTypes, 1);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i));
                    }
                }
            }
        }


        public delegate void F_EC<T0>(Entity entity, T0 c0)
            where T0 : class;

        public unsafe void ForEach<T0>(F_EC<T0> action)
            where T0 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[1];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();

                    query = ResolveEntityQuery(delegateTypes, 1);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i]);
                    }
                }
            }
        }


        public delegate void F_C<T0>(T0 c0)
            where T0 : class;

        public unsafe void ForEach<T0>(F_C<T0> action)
            where T0 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[1];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();

                    query = ResolveEntityQuery(delegateTypes, 1);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i]);
                    }
                }
            }
        }


        public delegate void F_EB<T0>(Entity entity, DynamicBuffer<T0> c0)
            where T0 : struct, IBufferElementData;

        public unsafe void ForEach<T0>(F_EB<T0> action)
            where T0 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[1];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();

                    query = ResolveEntityQuery(delegateTypes, 1);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i]);
                    }
                }
            }
        }


        public delegate void F_B<T0>(DynamicBuffer<T0> c0)
            where T0 : struct, IBufferElementData;

        public unsafe void ForEach<T0>(F_B<T0> action)
            where T0 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[1];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();

                    query = ResolveEntityQuery(delegateTypes, 1);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i]);
                    }
                }
            }
        }


        public delegate void F_ES<T0>(Entity entity, T0 c0)
            where T0 : struct, ISharedComponentData;

        public unsafe void ForEach<T0>(F_ES<T0> action)
            where T0 : struct, ISharedComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[1];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();

                    query = ResolveEntityQuery(delegateTypes, 1);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0);
                    }
                }
            }
        }


        public delegate void F_S<T0>(T0 c0)
            where T0 : struct, ISharedComponentData;

        public unsafe void ForEach<T0>(F_S<T0> action)
            where T0 : struct, ISharedComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[1];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();

                    query = ResolveEntityQuery(delegateTypes, 1);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0);
                    }
                }
            }
        }


        public delegate void F_EDD<T0, T1>(Entity entity, ref T0 c0, ref T1 c1)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData;

        public unsafe void ForEach<T0, T1>(F_EDD<T0, T1> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
        }


        public delegate void F_DD<T0, T1>(ref T0 c0, ref T1 c1)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData;

        public unsafe void ForEach<T0, T1>(F_DD<T0, T1> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
        }


        public delegate void F_EDDD<T0, T1, T2>(Entity entity, ref T0 c0, ref T1 c1, ref T2 c2)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2>(F_EDDD<T0, T1, T2> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
        }


        public delegate void F_DDD<T0, T1, T2>(ref T0 c0, ref T1 c1, ref T2 c2)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2>(F_DDD<T0, T1, T2> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
        }


        public delegate void F_EDDDD<T0, T1, T2, T3>(Entity entity, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_EDDDD<T0, T1, T2, T3> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
        }


        public delegate void F_DDDD<T0, T1, T2, T3>(ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_DDDD<T0, T1, T2, T3> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
        }


        public delegate void F_EDDDDD<T0, T1, T2, T3, T4>(Entity entity, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_EDDDDD<T0, T1, T2, T3, T4> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
        }


        public delegate void F_DDDDD<T0, T1, T2, T3, T4>(ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_DDDDD<T0, T1, T2, T3, T4> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
        }


        public delegate void F_EDDDDDD<T0, T1, T2, T3, T4, T5>(Entity entity, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_EDDDDDD<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = m_System.GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
        }


        public delegate void F_DDDDDD<T0, T1, T2, T3, T4, T5>(ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_DDDDDD<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = m_System.GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
        }


        public delegate void F_ECD<T0, T1>(Entity entity, T0 c0, ref T1 c1)
            where T0 : class
            where T1 : struct, IComponentData;

        public unsafe void ForEach<T0, T1>(F_ECD<T0, T1> action)
            where T0 : class
            where T1 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
        }


        public delegate void F_CD<T0, T1>(T0 c0, ref T1 c1)
            where T0 : class
            where T1 : struct, IComponentData;

        public unsafe void ForEach<T0, T1>(F_CD<T0, T1> action)
            where T0 : class
            where T1 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
        }


        public delegate void F_ECDD<T0, T1, T2>(Entity entity, T0 c0, ref T1 c1, ref T2 c2)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2>(F_ECDD<T0, T1, T2> action)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
        }


        public delegate void F_CDD<T0, T1, T2>(T0 c0, ref T1 c1, ref T2 c2)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2>(F_CDD<T0, T1, T2> action)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
        }


        public delegate void F_ECDDD<T0, T1, T2, T3>(Entity entity, T0 c0, ref T1 c1, ref T2 c2, ref T3 c3)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_ECDDD<T0, T1, T2, T3> action)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
        }


        public delegate void F_CDDD<T0, T1, T2, T3>(T0 c0, ref T1 c1, ref T2 c2, ref T3 c3)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_CDDD<T0, T1, T2, T3> action)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
        }


        public delegate void F_ECDDDD<T0, T1, T2, T3, T4>(Entity entity, T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_ECDDDD<T0, T1, T2, T3, T4> action)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
        }


        public delegate void F_CDDDD<T0, T1, T2, T3, T4>(T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_CDDDD<T0, T1, T2, T3, T4> action)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
        }


        public delegate void F_ECDDDDD<T0, T1, T2, T3, T4, T5>(Entity entity, T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_ECDDDDD<T0, T1, T2, T3, T4, T5> action)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = m_System.GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
        }


        public delegate void F_CDDDDD<T0, T1, T2, T3, T4, T5>(T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_CDDDDD<T0, T1, T2, T3, T4, T5> action)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = m_System.GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
        }


        public delegate void F_EBD<T0, T1>(Entity entity, DynamicBuffer<T0> c0, ref T1 c1)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData;

        public unsafe void ForEach<T0, T1>(F_EBD<T0, T1> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
        }


        public delegate void F_BD<T0, T1>(DynamicBuffer<T0> c0, ref T1 c1)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData;

        public unsafe void ForEach<T0, T1>(F_BD<T0, T1> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
        }


        public delegate void F_EBDD<T0, T1, T2>(Entity entity, DynamicBuffer<T0> c0, ref T1 c1, ref T2 c2)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2>(F_EBDD<T0, T1, T2> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
        }


        public delegate void F_BDD<T0, T1, T2>(DynamicBuffer<T0> c0, ref T1 c1, ref T2 c2)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2>(F_BDD<T0, T1, T2> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
        }


        public delegate void F_EBDDD<T0, T1, T2, T3>(Entity entity, DynamicBuffer<T0> c0, ref T1 c1, ref T2 c2, ref T3 c3)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_EBDDD<T0, T1, T2, T3> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
        }


        public delegate void F_BDDD<T0, T1, T2, T3>(DynamicBuffer<T0> c0, ref T1 c1, ref T2 c2, ref T3 c3)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_BDDD<T0, T1, T2, T3> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
        }


        public delegate void F_EBDDDD<T0, T1, T2, T3, T4>(Entity entity, DynamicBuffer<T0> c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_EBDDDD<T0, T1, T2, T3, T4> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
        }


        public delegate void F_BDDDD<T0, T1, T2, T3, T4>(DynamicBuffer<T0> c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_BDDDD<T0, T1, T2, T3, T4> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
        }


        public delegate void F_EBDDDDD<T0, T1, T2, T3, T4, T5>(Entity entity, DynamicBuffer<T0> c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_EBDDDDD<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = m_System.GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
        }


        public delegate void F_BDDDDD<T0, T1, T2, T3, T4, T5>(DynamicBuffer<T0> c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_BDDDDD<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = m_System.GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
        }


        public delegate void F_ESD<T0, T1>(Entity entity, T0 c0, ref T1 c1)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData;

        public unsafe void ForEach<T0, T1>(F_ESD<T0, T1> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
        }


        public delegate void F_SD<T0, T1>(T0 c0, ref T1 c1)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData;

        public unsafe void ForEach<T0, T1>(F_SD<T0, T1> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
        }


        public delegate void F_ESDD<T0, T1, T2>(Entity entity, T0 c0, ref T1 c1, ref T2 c2)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2>(F_ESDD<T0, T1, T2> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
        }


        public delegate void F_SDD<T0, T1, T2>(T0 c0, ref T1 c1, ref T2 c2)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2>(F_SDD<T0, T1, T2> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
        }


        public delegate void F_ESDDD<T0, T1, T2, T3>(Entity entity, T0 c0, ref T1 c1, ref T2 c2, ref T3 c3)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_ESDDD<T0, T1, T2, T3> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
        }


        public delegate void F_SDDD<T0, T1, T2, T3>(T0 c0, ref T1 c1, ref T2 c2, ref T3 c3)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_SDDD<T0, T1, T2, T3> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
        }


        public delegate void F_ESDDDD<T0, T1, T2, T3, T4>(Entity entity, T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_ESDDDD<T0, T1, T2, T3, T4> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
        }


        public delegate void F_SDDDD<T0, T1, T2, T3, T4>(T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_SDDDD<T0, T1, T2, T3, T4> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
        }


        public delegate void F_ESDDDDD<T0, T1, T2, T3, T4, T5>(Entity entity, T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_ESDDDDD<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = m_System.GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
        }


        public delegate void F_SDDDDD<T0, T1, T2, T3, T4, T5>(T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_SDDDDD<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = m_System.GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
        }


        public delegate void F_EDC<T0, T1>(Entity entity, ref T0 c0, T1 c1)
            where T0 : struct, IComponentData
            where T1 : class;

        public unsafe void ForEach<T0, T1>(F_EDC<T0, T1> action)
            where T0 : struct, IComponentData
            where T1 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i]);
                    }
                }
            }
        }


        public delegate void F_DC<T0, T1>(ref T0 c0, T1 c1)
            where T0 : struct, IComponentData
            where T1 : class;

        public unsafe void ForEach<T0, T1>(F_DC<T0, T1> action)
            where T0 : struct, IComponentData
            where T1 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i]);
                    }
                }
            }
        }


        public delegate void F_EDCC<T0, T1, T2>(Entity entity, ref T0 c0, T1 c1, T2 c2)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class;

        public unsafe void ForEach<T0, T1, T2>(F_EDCC<T0, T1, T2> action)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i]);
                    }
                }
            }
        }


        public delegate void F_DCC<T0, T1, T2>(ref T0 c0, T1 c1, T2 c2)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class;

        public unsafe void ForEach<T0, T1, T2>(F_DCC<T0, T1, T2> action)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i]);
                    }
                }
            }
        }


        public delegate void F_EDCCC<T0, T1, T2, T3>(Entity entity, ref T0 c0, T1 c1, T2 c2, T3 c3)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class;

        public unsafe void ForEach<T0, T1, T2, T3>(F_EDCCC<T0, T1, T2, T3> action)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i]);
                    }
                }
            }
        }


        public delegate void F_DCCC<T0, T1, T2, T3>(ref T0 c0, T1 c1, T2 c2, T3 c3)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class;

        public unsafe void ForEach<T0, T1, T2, T3>(F_DCCC<T0, T1, T2, T3> action)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i]);
                    }
                }
            }
        }


        public delegate void F_EDCCCC<T0, T1, T2, T3, T4>(Entity entity, ref T0 c0, T1 c1, T2 c2, T3 c3, T4 c4)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_EDCCCC<T0, T1, T2, T3, T4> action)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
        }


        public delegate void F_DCCCC<T0, T1, T2, T3, T4>(ref T0 c0, T1 c1, T2 c2, T3 c3, T4 c4)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_DCCCC<T0, T1, T2, T3, T4> action)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
        }


        public delegate void F_EDCCCCC<T0, T1, T2, T3, T4, T5>(Entity entity, ref T0 c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_EDCCCCC<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>();
                var chunkComponentType5 = m_System.GetArchetypeChunkComponentType<T5>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, m_System.EntityManager);
                        var array5 = chunk.GetComponentObjects(chunkComponentType5, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
        }


        public delegate void F_DCCCCC<T0, T1, T2, T3, T4, T5>(ref T0 c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_DCCCCC<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>();
                var chunkComponentType5 = m_System.GetArchetypeChunkComponentType<T5>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, m_System.EntityManager);
                        var array5 = chunk.GetComponentObjects(chunkComponentType5, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
        }


        public delegate void F_ECC<T0, T1>(Entity entity, T0 c0, T1 c1)
            where T0 : class
            where T1 : class;

        public unsafe void ForEach<T0, T1>(F_ECC<T0, T1> action)
            where T0 : class
            where T1 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i]);
                    }
                }
            }
        }


        public delegate void F_CC<T0, T1>(T0 c0, T1 c1)
            where T0 : class
            where T1 : class;

        public unsafe void ForEach<T0, T1>(F_CC<T0, T1> action)
            where T0 : class
            where T1 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i]);
                    }
                }
            }
        }


        public delegate void F_ECCC<T0, T1, T2>(Entity entity, T0 c0, T1 c1, T2 c2)
            where T0 : class
            where T1 : class
            where T2 : class;

        public unsafe void ForEach<T0, T1, T2>(F_ECCC<T0, T1, T2> action)
            where T0 : class
            where T1 : class
            where T2 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i], array2[i]);
                    }
                }
            }
        }


        public delegate void F_CCC<T0, T1, T2>(T0 c0, T1 c1, T2 c2)
            where T0 : class
            where T1 : class
            where T2 : class;

        public unsafe void ForEach<T0, T1, T2>(F_CCC<T0, T1, T2> action)
            where T0 : class
            where T1 : class
            where T2 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i], array2[i]);
                    }
                }
            }
        }


        public delegate void F_ECCCC<T0, T1, T2, T3>(Entity entity, T0 c0, T1 c1, T2 c2, T3 c3)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class;

        public unsafe void ForEach<T0, T1, T2, T3>(F_ECCCC<T0, T1, T2, T3> action)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i], array2[i], array3[i]);
                    }
                }
            }
        }


        public delegate void F_CCCC<T0, T1, T2, T3>(T0 c0, T1 c1, T2 c2, T3 c3)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class;

        public unsafe void ForEach<T0, T1, T2, T3>(F_CCCC<T0, T1, T2, T3> action)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i], array2[i], array3[i]);
                    }
                }
            }
        }


        public delegate void F_ECCCCC<T0, T1, T2, T3, T4>(Entity entity, T0 c0, T1 c1, T2 c2, T3 c3, T4 c4)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_ECCCCC<T0, T1, T2, T3, T4> action)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
        }


        public delegate void F_CCCCC<T0, T1, T2, T3, T4>(T0 c0, T1 c1, T2 c2, T3 c3, T4 c4)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_CCCCC<T0, T1, T2, T3, T4> action)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
        }


        public delegate void F_ECCCCCC<T0, T1, T2, T3, T4, T5>(Entity entity, T0 c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_ECCCCCC<T0, T1, T2, T3, T4, T5> action)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>();
                var chunkComponentType5 = m_System.GetArchetypeChunkComponentType<T5>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, m_System.EntityManager);
                        var array5 = chunk.GetComponentObjects(chunkComponentType5, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
        }


        public delegate void F_CCCCCC<T0, T1, T2, T3, T4, T5>(T0 c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_CCCCCC<T0, T1, T2, T3, T4, T5> action)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>();
                var chunkComponentType5 = m_System.GetArchetypeChunkComponentType<T5>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, m_System.EntityManager);
                        var array5 = chunk.GetComponentObjects(chunkComponentType5, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
        }


        public delegate void F_EBC<T0, T1>(Entity entity, DynamicBuffer<T0> c0, T1 c1)
            where T0 : struct, IBufferElementData
            where T1 : class;

        public unsafe void ForEach<T0, T1>(F_EBC<T0, T1> action)
            where T0 : struct, IBufferElementData
            where T1 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i]);
                    }
                }
            }
        }


        public delegate void F_BC<T0, T1>(DynamicBuffer<T0> c0, T1 c1)
            where T0 : struct, IBufferElementData
            where T1 : class;

        public unsafe void ForEach<T0, T1>(F_BC<T0, T1> action)
            where T0 : struct, IBufferElementData
            where T1 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i]);
                    }
                }
            }
        }


        public delegate void F_EBCC<T0, T1, T2>(Entity entity, DynamicBuffer<T0> c0, T1 c1, T2 c2)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class;

        public unsafe void ForEach<T0, T1, T2>(F_EBCC<T0, T1, T2> action)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i], array2[i]);
                    }
                }
            }
        }


        public delegate void F_BCC<T0, T1, T2>(DynamicBuffer<T0> c0, T1 c1, T2 c2)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class;

        public unsafe void ForEach<T0, T1, T2>(F_BCC<T0, T1, T2> action)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i], array2[i]);
                    }
                }
            }
        }


        public delegate void F_EBCCC<T0, T1, T2, T3>(Entity entity, DynamicBuffer<T0> c0, T1 c1, T2 c2, T3 c3)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class;

        public unsafe void ForEach<T0, T1, T2, T3>(F_EBCCC<T0, T1, T2, T3> action)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i], array2[i], array3[i]);
                    }
                }
            }
        }


        public delegate void F_BCCC<T0, T1, T2, T3>(DynamicBuffer<T0> c0, T1 c1, T2 c2, T3 c3)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class;

        public unsafe void ForEach<T0, T1, T2, T3>(F_BCCC<T0, T1, T2, T3> action)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i], array2[i], array3[i]);
                    }
                }
            }
        }


        public delegate void F_EBCCCC<T0, T1, T2, T3, T4>(Entity entity, DynamicBuffer<T0> c0, T1 c1, T2 c2, T3 c3, T4 c4)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_EBCCCC<T0, T1, T2, T3, T4> action)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
        }


        public delegate void F_BCCCC<T0, T1, T2, T3, T4>(DynamicBuffer<T0> c0, T1 c1, T2 c2, T3 c3, T4 c4)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_BCCCC<T0, T1, T2, T3, T4> action)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
        }


        public delegate void F_EBCCCCC<T0, T1, T2, T3, T4, T5>(Entity entity, DynamicBuffer<T0> c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_EBCCCCC<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>();
                var chunkComponentType5 = m_System.GetArchetypeChunkComponentType<T5>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, m_System.EntityManager);
                        var array5 = chunk.GetComponentObjects(chunkComponentType5, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
        }


        public delegate void F_BCCCCC<T0, T1, T2, T3, T4, T5>(DynamicBuffer<T0> c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_BCCCCC<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>();
                var chunkComponentType5 = m_System.GetArchetypeChunkComponentType<T5>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, m_System.EntityManager);
                        var array5 = chunk.GetComponentObjects(chunkComponentType5, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
        }


        public delegate void F_ESC<T0, T1>(Entity entity, T0 c0, T1 c1)
            where T0 : struct, ISharedComponentData
            where T1 : class;

        public unsafe void ForEach<T0, T1>(F_ESC<T0, T1> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0, array1[i]);
                    }
                }
            }
        }


        public delegate void F_SC<T0, T1>(T0 c0, T1 c1)
            where T0 : struct, ISharedComponentData
            where T1 : class;

        public unsafe void ForEach<T0, T1>(F_SC<T0, T1> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0, array1[i]);
                    }
                }
            }
        }


        public delegate void F_ESCC<T0, T1, T2>(Entity entity, T0 c0, T1 c1, T2 c2)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class;

        public unsafe void ForEach<T0, T1, T2>(F_ESCC<T0, T1, T2> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0, array1[i], array2[i]);
                    }
                }
            }
        }


        public delegate void F_SCC<T0, T1, T2>(T0 c0, T1 c1, T2 c2)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class;

        public unsafe void ForEach<T0, T1, T2>(F_SCC<T0, T1, T2> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0, array1[i], array2[i]);
                    }
                }
            }
        }


        public delegate void F_ESCCC<T0, T1, T2, T3>(Entity entity, T0 c0, T1 c1, T2 c2, T3 c3)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class;

        public unsafe void ForEach<T0, T1, T2, T3>(F_ESCCC<T0, T1, T2, T3> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0, array1[i], array2[i], array3[i]);
                    }
                }
            }
        }


        public delegate void F_SCCC<T0, T1, T2, T3>(T0 c0, T1 c1, T2 c2, T3 c3)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class;

        public unsafe void ForEach<T0, T1, T2, T3>(F_SCCC<T0, T1, T2, T3> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0, array1[i], array2[i], array3[i]);
                    }
                }
            }
        }


        public delegate void F_ESCCCC<T0, T1, T2, T3, T4>(Entity entity, T0 c0, T1 c1, T2 c2, T3 c3, T4 c4)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_ESCCCC<T0, T1, T2, T3, T4> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0, array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
        }


        public delegate void F_SCCCC<T0, T1, T2, T3, T4>(T0 c0, T1 c1, T2 c2, T3 c3, T4 c4)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_SCCCC<T0, T1, T2, T3, T4> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0, array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
        }


        public delegate void F_ESCCCCC<T0, T1, T2, T3, T4, T5>(Entity entity, T0 c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_ESCCCCC<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>();
                var chunkComponentType5 = m_System.GetArchetypeChunkComponentType<T5>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, m_System.EntityManager);
                        var array5 = chunk.GetComponentObjects(chunkComponentType5, m_System.EntityManager);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0, array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
        }


        public delegate void F_SCCCCC<T0, T1, T2, T3, T4, T5>(T0 c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_SCCCCC<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = m_System.GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = m_System.GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = m_System.GetArchetypeChunkComponentType<T4>();
                var chunkComponentType5 = m_System.GetArchetypeChunkComponentType<T5>();

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, m_System.EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, m_System.EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, m_System.EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, m_System.EntityManager);
                        var array5 = chunk.GetComponentObjects(chunkComponentType5, m_System.EntityManager);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0, array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
        }


        public delegate void F_EDB<T0, T1>(Entity entity, ref T0 c0, DynamicBuffer<T1> c1)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1>(F_EDB<T0, T1> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i]);
                    }
                }
            }
        }


        public delegate void F_DB<T0, T1>(ref T0 c0, DynamicBuffer<T1> c1)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1>(F_DB<T0, T1> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i]);
                    }
                }
            }
        }


        public delegate void F_EDBB<T0, T1, T2>(Entity entity, ref T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2>(F_EDBB<T0, T1, T2> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i]);
                    }
                }
            }
        }


        public delegate void F_DBB<T0, T1, T2>(ref T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2>(F_DBB<T0, T1, T2> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i]);
                    }
                }
            }
        }


        public delegate void F_EDBBB<T0, T1, T2, T3>(Entity entity, ref T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_EDBBB<T0, T1, T2, T3> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i]);
                    }
                }
            }
        }


        public delegate void F_DBBB<T0, T1, T2, T3>(ref T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_DBBB<T0, T1, T2, T3> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i]);
                    }
                }
            }
        }


        public delegate void F_EDBBBB<T0, T1, T2, T3, T4>(Entity entity, ref T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3, DynamicBuffer<T4> c4)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_EDBBBB<T0, T1, T2, T3, T4> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkBufferType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var array4 = chunk.GetBufferAccessor(chunkComponentType4);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
        }


        public delegate void F_DBBBB<T0, T1, T2, T3, T4>(ref T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3, DynamicBuffer<T4> c4)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_DBBBB<T0, T1, T2, T3, T4> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkBufferType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var array4 = chunk.GetBufferAccessor(chunkComponentType4);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
        }


        public delegate void F_EDBBBBB<T0, T1, T2, T3, T4, T5>(Entity entity, ref T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3, DynamicBuffer<T4> c4, DynamicBuffer<T5> c5)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_EDBBBBB<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkBufferType<T4>(false);
                var chunkComponentType5 = m_System.GetArchetypeChunkBufferType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var array4 = chunk.GetBufferAccessor(chunkComponentType4);
                        var array5 = chunk.GetBufferAccessor(chunkComponentType5);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
        }


        public delegate void F_DBBBBB<T0, T1, T2, T3, T4, T5>(ref T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3, DynamicBuffer<T4> c4, DynamicBuffer<T5> c5)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_DBBBBB<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkBufferType<T4>(false);
                var chunkComponentType5 = m_System.GetArchetypeChunkBufferType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var array4 = chunk.GetBufferAccessor(chunkComponentType4);
                        var array5 = chunk.GetBufferAccessor(chunkComponentType5);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
        }


        public delegate void F_ECB<T0, T1>(Entity entity, T0 c0, DynamicBuffer<T1> c1)
            where T0 : class
            where T1 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1>(F_ECB<T0, T1> action)
            where T0 : class
            where T1 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i]);
                    }
                }
            }
        }


        public delegate void F_CB<T0, T1>(T0 c0, DynamicBuffer<T1> c1)
            where T0 : class
            where T1 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1>(F_CB<T0, T1> action)
            where T0 : class
            where T1 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i]);
                    }
                }
            }
        }


        public delegate void F_ECBB<T0, T1, T2>(Entity entity, T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2>(F_ECBB<T0, T1, T2> action)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i], array2[i]);
                    }
                }
            }
        }


        public delegate void F_CBB<T0, T1, T2>(T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2>(F_CBB<T0, T1, T2> action)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i], array2[i]);
                    }
                }
            }
        }


        public delegate void F_ECBBB<T0, T1, T2, T3>(Entity entity, T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_ECBBB<T0, T1, T2, T3> action)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i], array2[i], array3[i]);
                    }
                }
            }
        }


        public delegate void F_CBBB<T0, T1, T2, T3>(T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_CBBB<T0, T1, T2, T3> action)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i], array2[i], array3[i]);
                    }
                }
            }
        }


        public delegate void F_ECBBBB<T0, T1, T2, T3, T4>(Entity entity, T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3, DynamicBuffer<T4> c4)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_ECBBBB<T0, T1, T2, T3, T4> action)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkBufferType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var array4 = chunk.GetBufferAccessor(chunkComponentType4);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
        }


        public delegate void F_CBBBB<T0, T1, T2, T3, T4>(T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3, DynamicBuffer<T4> c4)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_CBBBB<T0, T1, T2, T3, T4> action)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkBufferType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var array4 = chunk.GetBufferAccessor(chunkComponentType4);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
        }


        public delegate void F_ECBBBBB<T0, T1, T2, T3, T4, T5>(Entity entity, T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3, DynamicBuffer<T4> c4, DynamicBuffer<T5> c5)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_ECBBBBB<T0, T1, T2, T3, T4, T5> action)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkBufferType<T4>(false);
                var chunkComponentType5 = m_System.GetArchetypeChunkBufferType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var array4 = chunk.GetBufferAccessor(chunkComponentType4);
                        var array5 = chunk.GetBufferAccessor(chunkComponentType5);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
        }


        public delegate void F_CBBBBB<T0, T1, T2, T3, T4, T5>(T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3, DynamicBuffer<T4> c4, DynamicBuffer<T5> c5)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_CBBBBB<T0, T1, T2, T3, T4, T5> action)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkBufferType<T4>(false);
                var chunkComponentType5 = m_System.GetArchetypeChunkBufferType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetComponentObjects(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var array4 = chunk.GetBufferAccessor(chunkComponentType4);
                        var array5 = chunk.GetBufferAccessor(chunkComponentType5);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
        }


        public delegate void F_EBB<T0, T1>(Entity entity, DynamicBuffer<T0> c0, DynamicBuffer<T1> c1)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1>(F_EBB<T0, T1> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i]);
                    }
                }
            }
        }


        public delegate void F_BB<T0, T1>(DynamicBuffer<T0> c0, DynamicBuffer<T1> c1)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1>(F_BB<T0, T1> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i]);
                    }
                }
            }
        }


        public delegate void F_EBBB<T0, T1, T2>(Entity entity, DynamicBuffer<T0> c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2>(F_EBBB<T0, T1, T2> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i], array2[i]);
                    }
                }
            }
        }


        public delegate void F_BBB<T0, T1, T2>(DynamicBuffer<T0> c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2>(F_BBB<T0, T1, T2> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i], array2[i]);
                    }
                }
            }
        }


        public delegate void F_EBBBB<T0, T1, T2, T3>(Entity entity, DynamicBuffer<T0> c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_EBBBB<T0, T1, T2, T3> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i], array2[i], array3[i]);
                    }
                }
            }
        }


        public delegate void F_BBBB<T0, T1, T2, T3>(DynamicBuffer<T0> c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_BBBB<T0, T1, T2, T3> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i], array2[i], array3[i]);
                    }
                }
            }
        }


        public delegate void F_EBBBBB<T0, T1, T2, T3, T4>(Entity entity, DynamicBuffer<T0> c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3, DynamicBuffer<T4> c4)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_EBBBBB<T0, T1, T2, T3, T4> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkBufferType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var array4 = chunk.GetBufferAccessor(chunkComponentType4);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
        }


        public delegate void F_BBBBB<T0, T1, T2, T3, T4>(DynamicBuffer<T0> c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3, DynamicBuffer<T4> c4)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_BBBBB<T0, T1, T2, T3, T4> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkBufferType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var array4 = chunk.GetBufferAccessor(chunkComponentType4);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
        }


        public delegate void F_EBBBBBB<T0, T1, T2, T3, T4, T5>(Entity entity, DynamicBuffer<T0> c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3, DynamicBuffer<T4> c4, DynamicBuffer<T5> c5)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_EBBBBBB<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkBufferType<T4>(false);
                var chunkComponentType5 = m_System.GetArchetypeChunkBufferType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var array4 = chunk.GetBufferAccessor(chunkComponentType4);
                        var array5 = chunk.GetBufferAccessor(chunkComponentType5);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0[i], array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
        }


        public delegate void F_BBBBBB<T0, T1, T2, T3, T4, T5>(DynamicBuffer<T0> c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3, DynamicBuffer<T4> c4, DynamicBuffer<T5> c5)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_BBBBBB<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkBufferType<T4>(false);
                var chunkComponentType5 = m_System.GetArchetypeChunkBufferType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var array4 = chunk.GetBufferAccessor(chunkComponentType4);
                        var array5 = chunk.GetBufferAccessor(chunkComponentType5);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0[i], array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
        }


        public delegate void F_ESB<T0, T1>(Entity entity, T0 c0, DynamicBuffer<T1> c1)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1>(F_ESB<T0, T1> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0, array1[i]);
                    }
                }
            }
        }


        public delegate void F_SB<T0, T1>(T0 c0, DynamicBuffer<T1> c1)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1>(F_SB<T0, T1> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[2];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();

                    query = ResolveEntityQuery(delegateTypes, 2);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0, array1[i]);
                    }
                }
            }
        }


        public delegate void F_ESBB<T0, T1, T2>(Entity entity, T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2>(F_ESBB<T0, T1, T2> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0, array1[i], array2[i]);
                    }
                }
            }
        }


        public delegate void F_SBB<T0, T1, T2>(T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2>(F_SBB<T0, T1, T2> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[3];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();

                    query = ResolveEntityQuery(delegateTypes, 3);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0, array1[i], array2[i]);
                    }
                }
            }
        }


        public delegate void F_ESBBB<T0, T1, T2, T3>(Entity entity, T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_ESBBB<T0, T1, T2, T3> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0, array1[i], array2[i], array3[i]);
                    }
                }
            }
        }


        public delegate void F_SBBB<T0, T1, T2, T3>(T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_SBBB<T0, T1, T2, T3> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[4];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();

                    query = ResolveEntityQuery(delegateTypes, 4);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0, array1[i], array2[i], array3[i]);
                    }
                }
            }
        }


        public delegate void F_ESBBBB<T0, T1, T2, T3, T4>(Entity entity, T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3, DynamicBuffer<T4> c4)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_ESBBBB<T0, T1, T2, T3, T4> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkBufferType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var array4 = chunk.GetBufferAccessor(chunkComponentType4);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0, array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
        }


        public delegate void F_SBBBB<T0, T1, T2, T3, T4>(T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3, DynamicBuffer<T4> c4)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_SBBBB<T0, T1, T2, T3, T4> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[5];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();

                    query = ResolveEntityQuery(delegateTypes, 5);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkBufferType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var array4 = chunk.GetBufferAccessor(chunkComponentType4);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0, array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
        }


        public delegate void F_ESBBBBB<T0, T1, T2, T3, T4, T5>(Entity entity, T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3, DynamicBuffer<T4> c4, DynamicBuffer<T5> c5)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_ESBBBBB<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var entityType = m_System.GetArchetypeChunkEntityType();
                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkBufferType<T4>(false);
                var chunkComponentType5 = m_System.GetArchetypeChunkBufferType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var array4 = chunk.GetBufferAccessor(chunkComponentType4);
                        var array5 = chunk.GetBufferAccessor(chunkComponentType5);
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(entityArray[i], array0, array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
        }


        public delegate void F_SBBBBB<T0, T1, T2, T3, T4, T5>(T0 c0, DynamicBuffer<T1> c1, DynamicBuffer<T2> c2, DynamicBuffer<T3> c3, DynamicBuffer<T4> c4, DynamicBuffer<T5> c5)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_SBBBBB<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc int[6];
                    delegateTypes[0] = TypeManager.GetTypeIndex<T0>();
                    delegateTypes[1] = TypeManager.GetTypeIndex<T1>();
                    delegateTypes[2] = TypeManager.GetTypeIndex<T2>();
                    delegateTypes[3] = TypeManager.GetTypeIndex<T3>();
                    delegateTypes[4] = TypeManager.GetTypeIndex<T4>();
                    delegateTypes[5] = TypeManager.GetTypeIndex<T5>();

                    query = ResolveEntityQuery(delegateTypes, 6);
                }

                var chunkComponentType0 = m_System.GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = m_System.GetArchetypeChunkBufferType<T1>(false);
                var chunkComponentType2 = m_System.GetArchetypeChunkBufferType<T2>(false);
                var chunkComponentType3 = m_System.GetArchetypeChunkBufferType<T3>(false);
                var chunkComponentType4 = m_System.GetArchetypeChunkBufferType<T4>(false);
                var chunkComponentType5 = m_System.GetArchetypeChunkBufferType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, m_System.EntityManager);
                        var array1 = chunk.GetBufferAccessor(chunkComponentType1);
                        var array2 = chunk.GetBufferAccessor(chunkComponentType2);
                        var array3 = chunk.GetBufferAccessor(chunkComponentType3);
                        var array4 = chunk.GetBufferAccessor(chunkComponentType4);
                        var array5 = chunk.GetBufferAccessor(chunkComponentType5);

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            action(array0, array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
        }

    }


    // Schedule() implementation for DOTS-standalone.
    // The IDE calls Schedule(), and then code-gen is used to
    // replace the call to the correct Schedule_D method, With
    // known types.

#if UNITY_ZEROPLAYER
	public static partial class JobForEachExtensions {

        // This method is used by the IDE, and is what will be replaced by one of the Schedule_D methods below.
        public unsafe static JobHandle Schedule<TJob>(this TJob job, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IBaseJobForEach
        {
            throw new NotImplementedException("Schedule<TJob>() should have been replaced by code-gen.");
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        public unsafe static JobHandle Schedule_D<TJob, T0>(TJob job, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0>
            where T0 : struct, IComponentData
        {
            {
                EntityQuery query = null;
                if (query== null)
                {
                    var delegateTypes = stackalloc ComponentType[1];
                    delegateTypes[0] = ComponentType.ReadWrite<T0>();

                    query = /*ResolveEntityQuery*/system.GetEntityQueryInternal(delegateTypes, 1);
                }

                var chunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            job.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i));
                    }
                }
            }
            return new JobHandle();
        }


        [EditorBrowsable(EditorBrowsableState.Never)]
        public unsafe static JobHandle Schedule_ED<TJob, T0>(TJob job, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0>
            where T0 : struct, IComponentData
        {
            {
                EntityQuery query = null;
                if (query== null)
                {
                    var delegateTypes = stackalloc ComponentType[1];
                    delegateTypes[0] = ComponentType.ReadWrite<T0>();

                    query = /*ResolveEntityQuery*/system.GetEntityQueryInternal(delegateTypes, 1);
                }

                var entityType = system.GetArchetypeChunkEntityType();
                var chunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            job.Execute(entityArray[i], entityArray[i].Index, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i));
                    }
                }
            }
            return new JobHandle();
        }


        [EditorBrowsable(EditorBrowsableState.Never)]
        public unsafe static JobHandle Schedule_DD<TJob, T0, T1>(TJob job, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        {
            {
                EntityQuery query = null;
                if (query== null)
                {
                    var delegateTypes = stackalloc ComponentType[2];
                    delegateTypes[0] = ComponentType.ReadWrite<T0>();
                    delegateTypes[1] = ComponentType.ReadWrite<T1>();

                    query = /*ResolveEntityQuery*/system.GetEntityQueryInternal(delegateTypes, 2);
                }

                var chunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            job.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
            return new JobHandle();
        }


        [EditorBrowsable(EditorBrowsableState.Never)]
        public unsafe static JobHandle Schedule_EDD<TJob, T0, T1>(TJob job, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        {
            {
                EntityQuery query = null;
                if (query== null)
                {
                    var delegateTypes = stackalloc ComponentType[2];
                    delegateTypes[0] = ComponentType.ReadWrite<T0>();
                    delegateTypes[1] = ComponentType.ReadWrite<T1>();

                    query = /*ResolveEntityQuery*/system.GetEntityQueryInternal(delegateTypes, 2);
                }

                var entityType = system.GetArchetypeChunkEntityType();
                var chunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            job.Execute(entityArray[i], entityArray[i].Index, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
            return new JobHandle();
        }


        [EditorBrowsable(EditorBrowsableState.Never)]
        public unsafe static JobHandle Schedule_DDD<TJob, T0, T1, T2>(TJob job, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            {
                EntityQuery query = null;
                if (query== null)
                {
                    var delegateTypes = stackalloc ComponentType[3];
                    delegateTypes[0] = ComponentType.ReadWrite<T0>();
                    delegateTypes[1] = ComponentType.ReadWrite<T1>();
                    delegateTypes[2] = ComponentType.ReadWrite<T2>();

                    query = /*ResolveEntityQuery*/system.GetEntityQueryInternal(delegateTypes, 3);
                }

                var chunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            job.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
            return new JobHandle();
        }


        [EditorBrowsable(EditorBrowsableState.Never)]
        public unsafe static JobHandle Schedule_EDDD<TJob, T0, T1, T2>(TJob job, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            {
                EntityQuery query = null;
                if (query== null)
                {
                    var delegateTypes = stackalloc ComponentType[3];
                    delegateTypes[0] = ComponentType.ReadWrite<T0>();
                    delegateTypes[1] = ComponentType.ReadWrite<T1>();
                    delegateTypes[2] = ComponentType.ReadWrite<T2>();

                    query = /*ResolveEntityQuery*/system.GetEntityQueryInternal(delegateTypes, 3);
                }

                var entityType = system.GetArchetypeChunkEntityType();
                var chunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            job.Execute(entityArray[i], entityArray[i].Index, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
            return new JobHandle();
        }


        [EditorBrowsable(EditorBrowsableState.Never)]
        public unsafe static JobHandle Schedule_DDDD<TJob, T0, T1, T2, T3>(TJob job, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            {
                EntityQuery query = null;
                if (query== null)
                {
                    var delegateTypes = stackalloc ComponentType[4];
                    delegateTypes[0] = ComponentType.ReadWrite<T0>();
                    delegateTypes[1] = ComponentType.ReadWrite<T1>();
                    delegateTypes[2] = ComponentType.ReadWrite<T2>();
                    delegateTypes[3] = ComponentType.ReadWrite<T3>();

                    query = /*ResolveEntityQuery*/system.GetEntityQueryInternal(delegateTypes, 4);
                }

                var chunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            job.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
            return new JobHandle();
        }


        [EditorBrowsable(EditorBrowsableState.Never)]
        public unsafe static JobHandle Schedule_EDDDD<TJob, T0, T1, T2, T3>(TJob job, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            {
                EntityQuery query = null;
                if (query== null)
                {
                    var delegateTypes = stackalloc ComponentType[4];
                    delegateTypes[0] = ComponentType.ReadWrite<T0>();
                    delegateTypes[1] = ComponentType.ReadWrite<T1>();
                    delegateTypes[2] = ComponentType.ReadWrite<T2>();
                    delegateTypes[3] = ComponentType.ReadWrite<T3>();

                    query = /*ResolveEntityQuery*/system.GetEntityQueryInternal(delegateTypes, 4);
                }

                var entityType = system.GetArchetypeChunkEntityType();
                var chunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            job.Execute(entityArray[i], entityArray[i].Index, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
            return new JobHandle();
        }


        [EditorBrowsable(EditorBrowsableState.Never)]
        public unsafe static JobHandle Schedule_DDDDD<TJob, T0, T1, T2, T3, T4>(TJob job, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            {
                EntityQuery query = null;
                if (query== null)
                {
                    var delegateTypes = stackalloc ComponentType[5];
                    delegateTypes[0] = ComponentType.ReadWrite<T0>();
                    delegateTypes[1] = ComponentType.ReadWrite<T1>();
                    delegateTypes[2] = ComponentType.ReadWrite<T2>();
                    delegateTypes[3] = ComponentType.ReadWrite<T3>();
                    delegateTypes[4] = ComponentType.ReadWrite<T4>();

                    query = /*ResolveEntityQuery*/system.GetEntityQueryInternal(delegateTypes, 5);
                }

                var chunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = system.GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            job.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
            return new JobHandle();
        }


        [EditorBrowsable(EditorBrowsableState.Never)]
        public unsafe static JobHandle Schedule_EDDDDD<TJob, T0, T1, T2, T3, T4>(TJob job, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            {
                EntityQuery query = null;
                if (query== null)
                {
                    var delegateTypes = stackalloc ComponentType[5];
                    delegateTypes[0] = ComponentType.ReadWrite<T0>();
                    delegateTypes[1] = ComponentType.ReadWrite<T1>();
                    delegateTypes[2] = ComponentType.ReadWrite<T2>();
                    delegateTypes[3] = ComponentType.ReadWrite<T3>();
                    delegateTypes[4] = ComponentType.ReadWrite<T4>();

                    query = /*ResolveEntityQuery*/system.GetEntityQueryInternal(delegateTypes, 5);
                }

                var entityType = system.GetArchetypeChunkEntityType();
                var chunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = system.GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            job.Execute(entityArray[i], entityArray[i].Index, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
            return new JobHandle();
        }


        [EditorBrowsable(EditorBrowsableState.Never)]
        public unsafe static JobHandle Schedule_DDDDDD<TJob, T0, T1, T2, T3, T4, T5>(TJob job, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            {
                EntityQuery query = null;
                if (query== null)
                {
                    var delegateTypes = stackalloc ComponentType[6];
                    delegateTypes[0] = ComponentType.ReadWrite<T0>();
                    delegateTypes[1] = ComponentType.ReadWrite<T1>();
                    delegateTypes[2] = ComponentType.ReadWrite<T2>();
                    delegateTypes[3] = ComponentType.ReadWrite<T3>();
                    delegateTypes[4] = ComponentType.ReadWrite<T4>();
                    delegateTypes[5] = ComponentType.ReadWrite<T5>();

                    query = /*ResolveEntityQuery*/system.GetEntityQueryInternal(delegateTypes, 6);
                }

                var chunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = system.GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = system.GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            job.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
            return new JobHandle();
        }


        [EditorBrowsable(EditorBrowsableState.Never)]
        public unsafe static JobHandle Schedule_EDDDDDD<TJob, T0, T1, T2, T3, T4, T5>(TJob job, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            {
                EntityQuery query = null;
                if (query== null)
                {
                    var delegateTypes = stackalloc ComponentType[6];
                    delegateTypes[0] = ComponentType.ReadWrite<T0>();
                    delegateTypes[1] = ComponentType.ReadWrite<T1>();
                    delegateTypes[2] = ComponentType.ReadWrite<T2>();
                    delegateTypes[3] = ComponentType.ReadWrite<T3>();
                    delegateTypes[4] = ComponentType.ReadWrite<T4>();
                    delegateTypes[5] = ComponentType.ReadWrite<T5>();

                    query = /*ResolveEntityQuery*/system.GetEntityQueryInternal(delegateTypes, 6);
                }

                var entityType = system.GetArchetypeChunkEntityType();
                var chunkComponentType0 = system.GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = system.GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = system.GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = system.GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = system.GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = system.GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                        var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();

                        for (int i = 0, count = chunk.Count; i < count; ++i)
                            job.Execute(entityArray[i], entityArray[i].Index, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
            return new JobHandle();
        }

    }
#endif // UNITY_ZEROPLAYER

} // namespace Unity.Entities

